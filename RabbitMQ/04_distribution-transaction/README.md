# 分布式事务

> 分布式事务是指事务的操作位于不同的节点上，需要保证事务的ACID特性
>
> 例如在下订单的场景，库存和订单如果不在同一个节点上，就涉及分布式事务

在分布式系统中，要实现分布式事务，无外乎几种方式

## 1.两阶段提交(2PC)

> 两阶段提交(Two-phase Commit, 2PC)，通过引入协调者(Coordinator)来协调参与者的行为，并最终决定这些参与者是否要真正执行事务

需要数据库厂商的支持，java组件有atomikos等

1. `准备阶段` 
   协调者询问参与者事务是否执行成功，参与者发回事务执行结果
2. `提交阶段` 
   如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务。否则，协调者发送通知让参与者回滚事务。
   需要注意的是，在准备阶段，参与者执行了事务，但还没提交。只要在提交阶段接收到协调者发来的通知后，才进行提交或者回滚

存在的一些问题

* `同步阻塞` 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作
* `单点问题` 协调者在2PC中起到非常大的作用，如果发生故障，特别是阶段二发生故障时会造成很大的影响，所有参与者都会处于阻塞状态，无法完成其它操作
* `数据不一致` 在阶段二，如果协调者只发送了部分commit信息，此时网络发生异常，那么只有部分参与者接受到commit消息，也就是说只有部分参与者提交了事务，使得系统数据不一致
* `过于保守` 任意一个节点失效会导致整个事务失效，没有完善的容错机制

## 2.补偿事务(TCC)

> TCC是采用补偿机制，核心思想是：针对每个操作都要注册一个与其对应的确认和补偿(撤销)操作

TCC分为三个阶段

* `Try阶段` 主要是对业务系统做检测以及资源预留
* `Confirm阶段` 主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认Confirm阶段是不会出错的。即Try成功则Confirm一定成功
* `Cancel阶段` 主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放

优点：和2PC比起来，实现以及流程相对简单，但数据一致性比2PC要差

缺点：TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理



## 3.本地消息表(异步确保)

> 本地消息表与业务数据表处于同一数据库中，这样就能利用本地事务来保证在对这两个表的操作满足ACID，并且使用了消息队列来保证最终一致性

* 在分布式事务操作的一方完成写业务数据的操作之后向本地消息发送一个消息，本地事务能保证这个消息一定会被写入到本地消息表中
  之后将本地消息表中的消息转发到消息队列中，如果转发成功则消息从本地消息表中删除，否则继续重发
* 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作

优点：避免了分布式事务，实现了最终一致性

缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理



## 4.MQ事务消息

> 有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式是类似于采用二阶段提交，但是市面上的一些主流的MQ都是不支持事务消息的

以RabbitMQ为例，大致思路是

* Prepared消息，拿到消息地址
* 执行本地事务
* 通过第一阶段拿到的地址去访问消息，并修改状态

也就是说在业务方法内需要消息队列提交两次请求，一次发送消息和一次确认消息。

如果确认消息发送失败了，RabbitMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RabbitMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息，这样就保证了消息发送与本地事务同时成功或同时失败

优点：实现了最终一致性，不需要依赖本地数据库事务

缺点：实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源